from sqlalchemy.orm import Session
from . import models, schemas
from typing import List
from datetime import datetime

# -------------------
# USERS
# -------------------
def get_user(db: Session, user_id: int):
    return db.query(models.User).filter(models.User.id == user_id).first()

def get_user_by_email(db: Session, email: str):
    return db.query(models.User).filter(models.User.email == email).first()

def create_user(db: Session, user: schemas.UserCreate, hashed_password: str):
    db_user = models.User(email=user.email, hashed_password=hashed_password, role=user.role)
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user

def update_user(db: Session, user_id: int, update_data: schemas.UserUpdate):
    user = get_user(db, user_id)
    if not user:
        return None
    if update_data.email:
        user.email = update_data.email
    if update_data.password:
        user.hashed_password = update_data.password
    db.commit()
    db.refresh(user)
    return user

def delete_user(db: Session, user_id: int):
    user = get_user(db, user_id)
    if not user:
        return None
    db.delete(user)
    db.commit()
    return user

# -------------------
# SERVICES
# -------------------
def create_service(db: Session, service: schemas.ServiceCreate, user_id: int):
    db_service = models.Service(**service.dict(), owner_id=user_id)
    db.add(db_service)
    db.commit()
    db.refresh(db_service)
    return db_service

def get_services(db: Session, skip: int = 0, limit: int = 100):
    return db.query(models.Service).offset(skip).limit(limit).all()

# -------------------
# CONTRACTS
# -------------------
def create_contract(db: Session, client_id: int, contract: schemas.ContractCreate):
    db_contract = models.Contract(
        client_id=client_id,
        freelancer_id=contract.freelancer_id,
        service_id=contract.service_id,
        status=models.ContractStatus.pending,
        created_at=datetime.utcnow()
    )
    db.add(db_contract)
    db.commit()
    db.refresh(db_contract)
    return db_contract

def get_contract(db: Session, contract_id: int):
    return db.query(models.Contract).filter(models.Contract.id == contract_id).first()

def get_contracts_by_user(db: Session, user_id: int):
    return db.query(models.Contract).filter(
        (models.Contract.client_id == user_id) | (models.Contract.freelancer_id == user_id)
    ).all()

def update_contract_status(db: Session, contract_id: int, status: models.ContractStatus):
    contract = get_contract(db, contract_id)
    if not contract:
        return None
    contract.status = status
    db.commit()
    db.refresh(contract)
    return contract

def add_review_to_contract(db: Session, contract_id: int, rating: float, review: str):
    contract = get_contract(db, contract_id)
    if not contract:
        return None
    if contract.status != models.ContractStatus.completed:
        return None  # só permite avaliar contratos concluídos
    contract.rating = rating
    contract.review = review
    db.commit()
    db.refresh(contract)
    return contract

def get_contracts_by_status(db: Session, status: models.ContractStatus):
    return db.query(models.Contract).filter(models.Contract.status == status).all()

# -------------------
# MESSAGES
# -------------------
def create_message(db: Session, sender_id: int, message: schemas.MessageCreate):
    db_message = models.Message(
        contract_id=message.contract_id,
        sender_id=sender_id,
        text=message.text
    )
    db.add(db_message)
    db.commit()
    db.refresh(db_message)
    return db_message

def get_messages_by_contract(db: Session, contract_id: int):
    return db.query(models.Message).filter(models.Message.contract_id == contract_id).order_by(models.Message.created_at).all()
